module Task4_2 where

{-
  Задание 4.1
  Реализация монады над множеством из четырёх элементов.
  Реализуйте все требуемые классы типов и объясните, почему они реализованы именно так.
-}

data FourOf a = FourOf a a a a deriving(Show,Eq)

-- реализуйте классы `Functor`, `Applicative` и `Monad` для типа `FourOf`
-- таким образом, что
-- do { x <- FourOf 1 2 3 4; y <- FourOf 4 6 7 8; return $ x + y } === FourOf 5 8 10 12

instance Functor FourOf where

-- По определению функции fmap: извлечь из контекста значение, применить к нему
-- функцию, результат положить в такой же контекст.
-- fmap :: Functor f => (a -> b) -> f a -> f b

    fmap f (FourOf a b c d) = FourOf (f a) (f b) (f c) (f d)

-- Закон fmap id x === x выполнен.

instance Applicative FourOf where

-- pure принимает 1 агрумент типа a, возвращает его же в контексте.
-- В нашем случае в контексте необходимо хранить четыре значения - "размножим" их.

    pure x = FourOf x x x x

-- Закон pure f <*> x === f <$> x выполнен.

-- По принципу работы <*>: взять функцию, упакованную в контекст, применить ее к значению, 
-- упакованному в контекст, результат вернуть в таком же контексте.

    (<*>) (FourOf f1 f2 f3 f4) (FourOf x1 x2 x3 x4) = 
            FourOf (f1 x1) (f2 x2) (f3 x3) (f4 x4)

-- Такие определения функций позволяют писать:
-- pure length <*> (FourOf "ab" "abc" "abcd" "a") === FourOf 2 3 4 1
-- pure (+3) <*> pure 3 :: FourOf Double === FourOf 6.0 6.0 6.0 6.0


instance Monad FourOf where

-- Та же семантика, что и у функции pure: значение помещается в контекст.

    return = pure

-- Функция f применяется ко всем элементам монады.
-- Создается новая монада из полученных значений таким образом, чтобы законы не были нарушены,
-- особенно, первый.

    (>>=) (FourOf a b c d) f = FourOf a1 b2 c3 d4
        where 
            FourOf a1 _ _ _ = f a
            FourOf _ b2 _ _ = f b
            FourOf _ _ c3 _ = f c
            FourOf _ _ _ d4 = f d

-- Все три закона монад выполнены
-- return x >>= f === f x
-- m >>= return === m
-- (m >>= f) >>= g === m >>= (\x -> f x >>= g)

    
-- Требуемая в условии операция с do-синтаксисом выполняется успешно


