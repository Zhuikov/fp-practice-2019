module Task3_3 where

{-
  Задание 3.3
  Множество на основе предикатов
-}

newtype PSet a = PSet{ contains :: (a -> Bool) }

-- Реализуйте классы Monoid и Functor
-- Объясните в комментариях, почему они реализованы именно так

instance Functor PSet where

--    fmap f (PSet fun) = PSet (f fun)

instance Monoid (PSet a) where

-- Для удовлетворения закона моноида, нейтральный элемент нужно определить
-- таким образом.

    mempty = PSet (\x -> False)

-- "Соединить" два предиката можно операцией логического ИЛИ.
-- Пусть mappend для двух предикатов будет работать, как, например, для списка:
-- выбирается их объединение. 

    mappend (PSet fun1) (PSet fun2) = PSet (\x -> (fun1 x) || (fun2 x))

-- Также можно использовать логическое И. В таком случае функция mempty 
-- должна быть определена по-другому: 
-- mempty = PSet (\x -> True)

